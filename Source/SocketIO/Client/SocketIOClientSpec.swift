//
//  SocketIOClientSpec.swift
//  Socket.IO-Client-Swift
//
//  Created by Erik Little on 1/3/16.
//
//  Permission is hereby granted, free of charge, to any person obtaining a copy
//  of this software and associated documentation files (the "Software"), to deal
//  in the Software without restriction, including without limitation the rights
//  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
//  copies of the Software, and to permit persons to whom the Software is
//  furnished to do so, subject to the following conditions:
//
//  The above copyright notice and this permission notice shall be included in
//  all copies or substantial portions of the Software.
//
//  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
//  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
//  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
//  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
//  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
//  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
//  THE SOFTWARE.

import Dispatch


/// Defines the interface for a SocketIOClient.
protocol SocketIOClientSpec : class {
    /// The queue that all interaction with the client must be on.
    var handleQueue: DispatchQueue { get set }

    /// The namespace that this socket is currently connected to.
    ///
    /// **Must** start with a `/`.
    var nsp: String { get set }

    /// A list of packets that are waiting for binary data.
    ///
    /// The way that socket.io works all data should be sent directly after each packet.
    /// So this should ideally be an array of one packet waiting for data.
    var waitingPackets: [SocketPacket] { get set }

    /// Called when the client connects to a namespace. If the client was created with a namespace upfront,
    /// then this is only called when the client connects to that namespace.
    func didConnect(toNamespace namespace: String)

    /// Called when the client has disconnected from socket.io.
    func didDisconnect(reason: String)

    /// Called when the client encounters an error.
    func didError(reason: String)

    /// Called when socket.io has acked one of our emits. Causes the corresponding ack callback to be called.
    func handleAck(_ ack: Int, data: [Any])

    /// Called when we get an event from socket.io.
    func handleEvent(_ event: String, data: [Any], isInternalMessage: Bool, withAck ack: Int)

    /// Called on socket.io events.
    func handleClientEvent(_ event: SocketClientEvent, data: [Any])

    /// Call when you wish to leave a namespace and return to the default namespace.
    func leaveNamespace()

    /// Joins `namespace`.
    ///
    /// **Do not use this to join the default namespace.** Instead call `leaveNamespace`.
    ///
    /// - parameter namespace: The namespace to join.
    func joinNamespace(_ namespace: String)
}

extension SocketIOClientSpec {
    /// Default implementation.
    func didError(reason: String) {
        DefaultSocketLogger.Logger.error("\(reason)", type: "SocketIOClient")

        handleClientEvent(.error, data: [reason])
    }
}

/// The set of events that are generated by the client.
public enum SocketClientEvent : String {
    /// Emitted when the client connects. This is also called on a successful reconnection. A connect event gets one
    /// data item: the namespace that was connected to.
    ///
    /// ```swift
    /// socket.on(clientEvent: .connect) {data, ack in
    ///     guard let nsp = data[0] as? String else { return }
    ///     // Some logic using the nsp
    /// }
    /// ```
    case connect

    /// Called when the socket has disconnected and will not attempt to try to reconnect.
    case disconnect

    /// Called when an error occurs.
    case error

    /// Called when the client begins the reconnection process.
    case reconnect

    /// Called each time the client tries to reconnect to the server.
    case reconnectAttempt

    /// Called every time there is a change in the client's status.
    case statusChange
}
